<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3DGS å¿…èƒœè¿è¡Œç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        #status-bar {
            position: absolute; top: 0; left: 0; width: 100%; 
            padding: 15px; background: rgba(0,0,0,0.8); 
            color: #0f0; text-align: center; font-size: 14px; 
            z-index: 999; pointer-events: none;
        }

        #start-btn {
            position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%);
            padding: 12px 30px; font-size: 18px; border-radius: 25px;
            background: white; border: none; cursor: pointer; display: none;
            z-index: 1000;
        }
    </style>
    <!-- ä½¿ç”¨ v0.4.7 å¼•æ“ -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@mkkellogg/gaussian-splats-3d": "https://unpkg.com/@mkkellogg/gaussian-splats-3d@0.4.7/build/gaussian-splats-3d.module.js"
        }
    }
    </script>
</head>
<body>

    <div id="status-bar">å‡†å¤‡å¼€å§‹...</div>
    <button id="start-btn">å¼€å¯é™€èºä»ª</button>

    <script type="module">
        import * as THREE from 'three';
        import { Viewer } from '@mkkellogg/gaussian-splats-3d';

        // âœ… è¿™æ˜¯ä½ åˆšæ‰æµ‹è¯•æˆåŠŸçš„é“¾æ¥
        const MODEL_URL = 'https://huggingface.co/datasets/liu1230/my-3dgs/resolve/main/scene.splat';

        const status = document.getElementById('status-bar');
        const btn = document.getElementById('start-btn');
        let viewer;
        let isRunning = false;
        let initialGyro = null;
        
        // é™€èºä»ªé™åˆ¶
        const CLAMP_X = 0.5; 
        const CLAMP_Y = 0.6; 

        async function main() {
            // 1. åˆå§‹åŒ–å¼•æ“
            viewer = new Viewer({
                'cameraUp': [0, 1, 0],
                'initialCameraPosition': [0, 1, 4],
                'initialCameraLookAt': [0, 0, 0],
                'sharedMemoryForWorkers': false,
            });
            document.body.appendChild(viewer.renderer.domElement);

            // ============================================
            // ğŸš€ æ ¸å¿ƒä¿®æ”¹ï¼šæ‰‹åŠ¨ä¸‹è½½ï¼Œç»•è¿‡å¼•æ“çš„Bug
            // ============================================
            try {
                status.innerText = "ğŸš€ ç¬¬ä¸€æ­¥ï¼šæ­£åœ¨æ‰‹åŠ¨ä¸‹è½½æ–‡ä»¶...";
                
                // ä½¿ç”¨ fetch ä¸‹è½½ï¼ˆè¿™æ­¥åˆšæ‰è¯æ˜æ˜¯èƒ½é€šçš„ï¼‰
                const response = await fetch(MODEL_URL);
                if (!response.ok) throw new Error("ä¸‹è½½å¤±è´¥: " + response.status);

                // è¯»å–æ•°æ®æµ
                const reader = response.body.getReader();
                const contentLength = +response.headers.get('Content-Length'); // å°è¯•è·å–æ€»é•¿åº¦
                let receivedLength = 0; 
                let chunks = []; 

                while(true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    chunks.push(value);
                    receivedLength += value.length;
                    
                    // è®¡ç®—ä¸‹è½½è¿›åº¦
                    let progress = "ä¸‹è½½ä¸­";
                    if (contentLength) {
                        progress = Math.round((receivedLength / contentLength) * 100) + "%";
                    } else {
                        progress = (receivedLength / 1024 / 1024).toFixed(1) + " MB";
                    }
                    status.innerText = `ğŸ“¥ æ­£åœ¨ä¸‹è½½... ${progress}`;
                }

                status.innerText = "âš™ï¸ ä¸‹è½½å®Œæˆï¼Œæ­£åœ¨ç»„è£…æ•°æ®...";
                
                // æŠŠä¸‹è½½å¥½çš„ç¢ç‰‡æ‹¼æˆä¸€ä¸ªå®Œæ•´çš„ Blob
                const blob = new Blob(chunks);
                // ç”Ÿæˆä¸€ä¸ªæœ¬åœ°çš„ä¸´æ—¶é“¾æ¥ (blob:http://....)
                const localUrl = URL.createObjectURL(blob);

                status.innerText = "ğŸ¬ å¯åŠ¨æ¸²æŸ“å¼•æ“...";

                // æŠŠè¿™ä¸ªæœ¬åœ°é“¾æ¥å–‚ç»™å¼•æ“ï¼Œå¹¶å¼ºåˆ¶å‘Šè¯‰å®ƒè¿™æ˜¯ splat
                await viewer.addSplatScene(localUrl, {
                    'showLoadingUI': false,
                    'format': 'splat', // å¼ºåˆ¶æŒ‡å®šæ ¼å¼
                    'splatAlphaRemovalThreshold': 5, 
                    'scale': [1, 1, 1],
                    'rotation': [0, 0, 0, 1]
                });

                // æˆåŠŸï¼
                status.innerText = "âœ… åŠ è½½æˆåŠŸï¼";
                status.style.color = "#fff";
                btn.style.display = "block";
                
                // é‡Šæ”¾å†…å­˜
                URL.revokeObjectURL(localUrl);

            } catch (err) {
                console.error(err);
                status.innerText = "âŒ é”™è¯¯: " + err.message;
                status.style.color = "red";
            }
        }

        // æŒ‰é’®ç‚¹å‡»
        btn.addEventListener('click', () => {
            btn.style.display = 'none';
            status.style.display = 'none';
            viewer.start();
            isRunning = true;
            requestGyro();
        });

        function requestGyro() {
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                        } else {
                            alert('éœ€è¦å…è®¸é™€èºä»ªæƒé™');
                        }
                    }).catch(console.error);
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
            }
        }

        function handleOrientation(event) {
            if (!viewer || !isRunning) return;
            if (!initialGyro && event.alpha !== null) {
                initialGyro = { beta: event.beta, gamma: event.gamma };
                return;
            }
            if (!initialGyro) return;

            let deltaX = (event.beta - initialGyro.beta) * (Math.PI / 180);
            let deltaY = (event.gamma - initialGyro.gamma) * (Math.PI / 180);
            deltaX = Math.max(-CLAMP_X, Math.min(CLAMP_X, deltaX));
            deltaY = Math.max(-CLAMP_Y, Math.min(CLAMP_Y, deltaY));
            viewer.camera.rotation.set(deltaX, deltaY, 0, 'YXZ');
            viewer.update();
        }

        main();
    </script>
</body>
</html>
