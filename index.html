<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3DGS ç»ˆæé€šå…³ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        #status-bar {
            position: absolute; top: 0; left: 0; width: 100%; 
            padding: 15px; background: rgba(0,0,0,0.8); 
            color: #0f0; text-align: center; font-size: 14px; 
            z-index: 999; pointer-events: none;
        }

        #start-btn {
            position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%);
            padding: 12px 30px; font-size: 18px; border-radius: 25px;
            background: white; border: none; cursor: pointer; display: none;
            z-index: 1000;
        }
    </style>
    <!-- å¼•ç”¨ v0.4.7 å¼•æ“ -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@mkkellogg/gaussian-splats-3d": "https://unpkg.com/@mkkellogg/gaussian-splats-3d@0.4.7/build/gaussian-splats-3d.module.js"
        }
    }
    </script>
</head>
<body>

    <div id="status-bar">å‡†å¤‡å°±ç»ª...</div>
    <button id="start-btn">å¼€å¯é™€èºä»ª</button>

    <script type="module">
        import * as THREE from 'three';
        import { Viewer } from '@mkkellogg/gaussian-splats-3d';

        // ä½ çš„ HF ç›´é“¾
        const MODEL_URL = 'https://huggingface.co/datasets/liu1230/my-3dgs/resolve/main/scene.splat';

        const status = document.getElementById('status-bar');
        const btn = document.getElementById('start-btn');
        let viewer;
        let isRunning = false;
        let initialGyro = null;
        
        const CLAMP_X = 0.5; 
        const CLAMP_Y = 0.6; 

        async function main() {
            viewer = new Viewer({
                'cameraUp': [0, 1, 0],
                'initialCameraPosition': [0, 1, 4],
                'initialCameraLookAt': [0, 0, 0],
                'sharedMemoryForWorkers': false,
            });
            document.body.appendChild(viewer.renderer.domElement);

            try {
                // 1. æ‰‹åŠ¨ä¸‹è½½
                status.innerText = "ğŸš€ æ­£åœ¨ä¸‹è½½æ¨¡å‹æ•°æ®...";
                const response = await fetch(MODEL_URL);
                if (!response.ok) throw new Error("ä¸‹è½½å¤±è´¥: " + response.status);

                const reader = response.body.getReader();
                const contentLength = +response.headers.get('Content-Length');
                let receivedLength = 0; 
                let chunks = []; 

                while(true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    chunks.push(value);
                    receivedLength += value.length;
                    
                    let progress = contentLength ? Math.round((receivedLength / contentLength) * 100) + "%" : (receivedLength / 1024 / 1024).toFixed(1) + " MB";
                    status.innerText = `ğŸ“¥ ä¸‹è½½ä¸­... ${progress}`;
                }

                status.innerText = "âš™ï¸ æ­£åœ¨å¤„ç†æ•°æ®...";
                
                // 2. æ ¸å¿ƒä¿®æ”¹ï¼šç”Ÿæˆ Blob URL å¹¶åŠ ä¸Šã€æ¬ºéª—åç¼€ã€‘
                const blob = new Blob(chunks);
                const originalUrl = URL.createObjectURL(blob);
                
                // ğŸ‘‡ã€å…³é”®ä¸€æ­¥ã€‘åœ¨é“¾æ¥åé¢å¼ºè¡ŒåŠ ä¸Š #.splat
                // å¼•æ“çœ‹åˆ° .splat æ‰ä¼šå¼€å¿ƒï¼Œè€Œæµè§ˆå™¨ä¸‹è½½æ—¶ä¼šå¿½ç•¥ # åé¢çš„å†…å®¹
                const fakeUrl = originalUrl + '#.splat';

                status.innerText = "ğŸ¬ å¼•æ“åŠ è½½ä¸­...";

                // 3. æŠŠè¿™ä¸ªâ€œå¸¦å‡å‘â€çš„é“¾æ¥ä¼ è¿›å»
                await viewer.addSplatScene(fakeUrl, {
                    'showLoadingUI': false,
                    'splatAlphaRemovalThreshold': 5, 
                    'scale': [1, 1, 1],
                    'rotation': [0, 0, 0, 1]
                });

                status.innerText = "âœ… åŠ è½½æˆåŠŸï¼";
                status.style.color = "#fff";
                btn.style.display = "block";
                
                // æ¸…ç†å†…å­˜ï¼ˆæ³¨æ„ï¼šè¿™é‡Œä¸èƒ½é©¬ä¸Š revokeï¼Œå› ä¸ºå¼•æ“è¿˜åœ¨è¯»ï¼Œç¨å¾®å»¶è¿Ÿä¸€ç‚¹ï¼‰
                setTimeout(() => URL.revokeObjectURL(originalUrl), 10000);

            } catch (err) {
                console.error(err);
                status.innerText = "âŒ é”™è¯¯: " + err.message;
                status.style.color = "red";
            }
        }

        btn.addEventListener('click', () => {
            btn.style.display = 'none';
            status.style.display = 'none';
            viewer.start();
            isRunning = true;
            requestGyro();
        });

        function requestGyro() {
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                        } else {
                            alert('éœ€è¦å…è®¸é™€èºä»ªæƒé™');
                        }
                    }).catch(console.error);
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
            }
        }

        function handleOrientation(event) {
            if (!viewer || !isRunning) return;
            if (!initialGyro && event.alpha !== null) {
                initialGyro = { beta: event.beta, gamma: event.gamma };
                return;
            }
            if (!initialGyro) return;

            let deltaX = (event.beta - initialGyro.beta) * (Math.PI / 180);
            let deltaY = (event.gamma - initialGyro.gamma) * (Math.PI / 180);
            deltaX = Math.max(-CLAMP_X, Math.min(CLAMP_X, deltaX));
            deltaY = Math.max(-CLAMP_Y, Math.min(CLAMP_Y, deltaY));
            viewer.camera.rotation.set(deltaX, deltaY, 0, 'YXZ');
            viewer.update();
        }

        main();
    </script>
</body>
</html>
